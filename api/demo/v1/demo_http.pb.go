// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.5.0
// - protoc             v3.21.5
// source: api/demo/v1/demo.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
	common "goproject/api/common"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationTodoCreateTodo = "/api.demo.v1.Todo/CreateTodo"
const OperationTodoDeleteTodo = "/api.demo.v1.Todo/DeleteTodo"
const OperationTodoGetTodo = "/api.demo.v1.Todo/GetTodo"
const OperationTodoListTodo = "/api.demo.v1.Todo/ListTodo"
const OperationTodoLogin = "/api.demo.v1.Todo/Login"
const OperationTodoUpdateTodo = "/api.demo.v1.Todo/UpdateTodo"

type TodoHTTPServer interface {
	CreateTodo(context.Context, *CreateTodoRequest) (*common.UpdateResp, error)
	DeleteTodo(context.Context, *common.IDReq) (*common.UpdateResp, error)
	GetTodo(context.Context, *common.IDReq) (*GetTodoReply, error)
	ListTodo(context.Context, *ListTodoRequest) (*ListTodoReply, error)
	Login(context.Context, *LoginRequest) (*LoginReply, error)
	UpdateTodo(context.Context, *UpdateTodoRequest) (*common.UpdateResp, error)
}

func RegisterTodoHTTPServer(s *http.Server, srv TodoHTTPServer) {
	r := s.Route("/")
	r.POST("/todo/create", _Todo_CreateTodo0_HTTP_Handler(srv))
	r.PUT("/todo/update", _Todo_UpdateTodo0_HTTP_Handler(srv))
	r.DELETE("/todo/delete", _Todo_DeleteTodo0_HTTP_Handler(srv))
	r.GET("/todo/get", _Todo_GetTodo0_HTTP_Handler(srv))
	r.GET("/todo/list", _Todo_ListTodo0_HTTP_Handler(srv))
	r.POST("/sso/login", _Todo_Login0_HTTP_Handler(srv))
}

func _Todo_CreateTodo0_HTTP_Handler(srv TodoHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateTodoRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationTodoCreateTodo)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateTodo(ctx, req.(*CreateTodoRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*common.UpdateResp)
		return ctx.Result(200, reply)
	}
}

func _Todo_UpdateTodo0_HTTP_Handler(srv TodoHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateTodoRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationTodoUpdateTodo)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateTodo(ctx, req.(*UpdateTodoRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*common.UpdateResp)
		return ctx.Result(200, reply)
	}
}

func _Todo_DeleteTodo0_HTTP_Handler(srv TodoHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in common.IDReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationTodoDeleteTodo)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteTodo(ctx, req.(*common.IDReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*common.UpdateResp)
		return ctx.Result(200, reply)
	}
}

func _Todo_GetTodo0_HTTP_Handler(srv TodoHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in common.IDReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationTodoGetTodo)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetTodo(ctx, req.(*common.IDReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetTodoReply)
		return ctx.Result(200, reply)
	}
}

func _Todo_ListTodo0_HTTP_Handler(srv TodoHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListTodoRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationTodoListTodo)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListTodo(ctx, req.(*ListTodoRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListTodoReply)
		return ctx.Result(200, reply)
	}
}

func _Todo_Login0_HTTP_Handler(srv TodoHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in LoginRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationTodoLogin)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Login(ctx, req.(*LoginRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*LoginReply)
		return ctx.Result(200, reply)
	}
}

type TodoHTTPClient interface {
	CreateTodo(ctx context.Context, req *CreateTodoRequest, opts ...http.CallOption) (rsp *common.UpdateResp, err error)
	DeleteTodo(ctx context.Context, req *common.IDReq, opts ...http.CallOption) (rsp *common.UpdateResp, err error)
	GetTodo(ctx context.Context, req *common.IDReq, opts ...http.CallOption) (rsp *GetTodoReply, err error)
	ListTodo(ctx context.Context, req *ListTodoRequest, opts ...http.CallOption) (rsp *ListTodoReply, err error)
	Login(ctx context.Context, req *LoginRequest, opts ...http.CallOption) (rsp *LoginReply, err error)
	UpdateTodo(ctx context.Context, req *UpdateTodoRequest, opts ...http.CallOption) (rsp *common.UpdateResp, err error)
}

type TodoHTTPClientImpl struct {
	cc *http.Client
}

func NewTodoHTTPClient(client *http.Client) TodoHTTPClient {
	return &TodoHTTPClientImpl{client}
}

func (c *TodoHTTPClientImpl) CreateTodo(ctx context.Context, in *CreateTodoRequest, opts ...http.CallOption) (*common.UpdateResp, error) {
	var out common.UpdateResp
	pattern := "/todo/create"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationTodoCreateTodo))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *TodoHTTPClientImpl) DeleteTodo(ctx context.Context, in *common.IDReq, opts ...http.CallOption) (*common.UpdateResp, error) {
	var out common.UpdateResp
	pattern := "/todo/delete"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationTodoDeleteTodo))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *TodoHTTPClientImpl) GetTodo(ctx context.Context, in *common.IDReq, opts ...http.CallOption) (*GetTodoReply, error) {
	var out GetTodoReply
	pattern := "/todo/get"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationTodoGetTodo))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *TodoHTTPClientImpl) ListTodo(ctx context.Context, in *ListTodoRequest, opts ...http.CallOption) (*ListTodoReply, error) {
	var out ListTodoReply
	pattern := "/todo/list"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationTodoListTodo))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *TodoHTTPClientImpl) Login(ctx context.Context, in *LoginRequest, opts ...http.CallOption) (*LoginReply, error) {
	var out LoginReply
	pattern := "/sso/login"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationTodoLogin))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *TodoHTTPClientImpl) UpdateTodo(ctx context.Context, in *UpdateTodoRequest, opts ...http.CallOption) (*common.UpdateResp, error) {
	var out common.UpdateResp
	pattern := "/todo/update"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationTodoUpdateTodo))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
