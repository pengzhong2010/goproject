// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.5.0
// - protoc             v3.7.1
// source: api/thinktank/v1/doc.proto

package v1

import (
	context "context"

	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationDocCreateDoc = "/api.thinktank.v1.Doc/CreateDoc"
const OperationDocDeleteDoc = "/api.thinktank.v1.Doc/DeleteDoc"
const OperationDocGetDoc = "/api.thinktank.v1.Doc/GetDoc"
const OperationDocListDoc = "/api.thinktank.v1.Doc/ListDoc"
const OperationDocUpdateDoc = "/api.thinktank.v1.Doc/UpdateDoc"

type DocHTTPServer interface {
	CreateDoc(context.Context, *CreateDocRequest) (*UpdateResp, error)
	DeleteDoc(context.Context, *IDReq) (*UpdateResp, error)
	GetDoc(context.Context, *IDReq) (*GetDocReply, error)
	ListDoc(context.Context, *ListDocRequest) (*ListDocReply, error)
	UpdateDoc(context.Context, *UpdateDocRequest) (*UpdateResp, error)
}

func RegisterDocHTTPServer(s *http.Server, srv DocHTTPServer) {
	r := s.Route("/")
	r.POST("/doc/create", _Doc_CreateDoc0_HTTP_Handler(srv))
	r.PUT("/doc/update", _Doc_UpdateDoc0_HTTP_Handler(srv))
	r.DELETE("/doc/delete", _Doc_DeleteDoc0_HTTP_Handler(srv))
	r.GET("/doc/get", _Doc_GetDoc0_HTTP_Handler(srv))
	r.GET("/doc/list", _Doc_ListDoc0_HTTP_Handler(srv))
}

func _Doc_CreateDoc0_HTTP_Handler(srv DocHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateDocRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationDocCreateDoc)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateDoc(ctx, req.(*CreateDocRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateResp)
		return ctx.Result(200, reply)
	}
}

func _Doc_UpdateDoc0_HTTP_Handler(srv DocHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateDocRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationDocUpdateDoc)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateDoc(ctx, req.(*UpdateDocRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateResp)
		return ctx.Result(200, reply)
	}
}

func _Doc_DeleteDoc0_HTTP_Handler(srv DocHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in IDReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationDocDeleteDoc)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteDoc(ctx, req.(*IDReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateResp)
		return ctx.Result(200, reply)
	}
}

func _Doc_GetDoc0_HTTP_Handler(srv DocHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in IDReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationDocGetDoc)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetDoc(ctx, req.(*IDReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetDocReply)
		return ctx.Result(200, reply)
	}
}

func _Doc_ListDoc0_HTTP_Handler(srv DocHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListDocRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationDocListDoc)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListDoc(ctx, req.(*ListDocRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListDocReply)
		return ctx.Result(200, reply)
	}
}

type DocHTTPClient interface {
	CreateDoc(ctx context.Context, req *CreateDocRequest, opts ...http.CallOption) (rsp *UpdateResp, err error)
	DeleteDoc(ctx context.Context, req *IDReq, opts ...http.CallOption) (rsp *UpdateResp, err error)
	GetDoc(ctx context.Context, req *IDReq, opts ...http.CallOption) (rsp *GetDocReply, err error)
	ListDoc(ctx context.Context, req *ListDocRequest, opts ...http.CallOption) (rsp *ListDocReply, err error)
	UpdateDoc(ctx context.Context, req *UpdateDocRequest, opts ...http.CallOption) (rsp *UpdateResp, err error)
}

type DocHTTPClientImpl struct {
	cc *http.Client
}

func NewDocHTTPClient(client *http.Client) DocHTTPClient {
	return &DocHTTPClientImpl{client}
}

func (c *DocHTTPClientImpl) CreateDoc(ctx context.Context, in *CreateDocRequest, opts ...http.CallOption) (*UpdateResp, error) {
	var out UpdateResp
	pattern := "/doc/create"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationDocCreateDoc))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *DocHTTPClientImpl) DeleteDoc(ctx context.Context, in *IDReq, opts ...http.CallOption) (*UpdateResp, error) {
	var out UpdateResp
	pattern := "/doc/delete"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationDocDeleteDoc))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *DocHTTPClientImpl) GetDoc(ctx context.Context, in *IDReq, opts ...http.CallOption) (*GetDocReply, error) {
	var out GetDocReply
	pattern := "/doc/get"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationDocGetDoc))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *DocHTTPClientImpl) ListDoc(ctx context.Context, in *ListDocRequest, opts ...http.CallOption) (*ListDocReply, error) {
	var out ListDocReply
	pattern := "/doc/list"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationDocListDoc))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *DocHTTPClientImpl) UpdateDoc(ctx context.Context, in *UpdateDocRequest, opts ...http.CallOption) (*UpdateResp, error) {
	var out UpdateResp
	pattern := "/doc/update"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationDocUpdateDoc))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
